package game

import (
	"fmt"
	"strconv"
	"strings"
)

// ScriptContext provides all the information needed to execute a script
type ScriptContext struct {
	Game       *Game
	Card       *FieldCard  // The card that triggered the script
	Caster     *Player     // Player who owns/cast the card
	CasterUID  string      // UID of the caster
	Target     *FieldCard  // Target creature (if any)
	TargetUID  string      // Target player UID (if targeting a player)
}

// ExecuteScript parses and executes a card's custom script
// Returns events generated by the script execution
func ExecuteScript(script string, ctx *ScriptContext) []Event {
	if script == "" {
		return []Event{}
	}

	events := []Event{}

	// Split script into individual commands (separated by semicolons or newlines)
	commands := splitCommands(script)

	for _, cmd := range commands {
		cmd = strings.TrimSpace(cmd)
		if cmd == "" {
			continue
		}

		// Parse function call: FunctionName(args)
		funcName, args, err := parseFunction(cmd)
		if err != nil {
			events = append(events, Event{
				Type: "ScriptError",
				Data: map[string]interface{}{"error": err.Error(), "command": cmd},
			})
			continue
		}

		// Execute the function
		result := executeFunction(funcName, args, ctx)
		events = append(events, result...)
	}

	return events
}

// splitCommands splits a script into individual commands
func splitCommands(script string) []string {
	// Replace newlines with semicolons, then split
	script = strings.ReplaceAll(script, "\n", ";")
	return strings.Split(script, ";")
}

// parseFunction extracts function name and arguments from a command
func parseFunction(cmd string) (string, []string, error) {
	// Find the opening parenthesis
	parenStart := strings.Index(cmd, "(")
	if parenStart == -1 {
		return "", nil, fmt.Errorf("invalid function syntax: %s", cmd)
	}

	// Find the closing parenthesis
	parenEnd := strings.LastIndex(cmd, ")")
	if parenEnd == -1 || parenEnd < parenStart {
		return "", nil, fmt.Errorf("missing closing parenthesis: %s", cmd)
	}

	funcName := strings.TrimSpace(cmd[:parenStart])
	argsStr := cmd[parenStart+1 : parenEnd]

	// Parse arguments (comma-separated, with quote handling)
	args := parseArgs(argsStr)

	return funcName, args, nil
}

// parseArgs splits arguments by comma, handling quoted strings
func parseArgs(argsStr string) []string {
	args := []string{}
	current := ""
	inQuote := false
	quoteChar := rune(0)

	for _, c := range argsStr {
		if !inQuote && (c == '"' || c == '\'') {
			inQuote = true
			quoteChar = c
			continue
		}
		if inQuote && c == quoteChar {
			inQuote = false
			continue
		}
		if !inQuote && c == ',' {
			args = append(args, strings.TrimSpace(current))
			current = ""
			continue
		}
		current += string(c)
	}

	if current != "" || len(args) > 0 {
		args = append(args, strings.TrimSpace(current))
	}

	return args
}

// executeFunction executes a script function and returns events
func executeFunction(funcName string, args []string, ctx *ScriptContext) []Event {
	switch strings.ToLower(funcName) {
	case "draw":
		return scriptDraw(args, ctx)
	case "damage":
		return scriptDamage(args, ctx)
	case "heal":
		return scriptHeal(args, ctx)
	case "buff":
		return scriptBuff(args, ctx)
	case "gainmana":
		return scriptGainMana(args, ctx)
	case "discard":
		return scriptDiscard(args, ctx)
	case "destroy":
		return scriptDestroy(args, ctx)
	case "damagecreature":
		return scriptDamageCreature(args, ctx)
	case "tapcreature":
		return scriptTapCreature(args, ctx)
	case "bounce":
		return scriptBounce(args, ctx)
	default:
		return []Event{{
			Type: "ScriptError",
			Data: map[string]interface{}{"error": fmt.Sprintf("unknown function: %s", funcName)},
		}}
	}
}

// resolvePlayer resolves a player reference string to actual player
// Accepts: "caster", "opponent", "target", or a player UID
func resolvePlayer(ref string, ctx *ScriptContext) (*Player, string, error) {
	ref = strings.ToLower(strings.TrimSpace(ref))

	switch ref {
	case "caster", "self", "owner":
		return ctx.Caster, ctx.CasterUID, nil
	case "opponent", "enemy":
		for uid, p := range ctx.Game.Players {
			if uid != ctx.CasterUID {
				return p, uid, nil
			}
		}
		return nil, "", fmt.Errorf("no opponent found")
	case "target":
		if ctx.TargetUID != "" {
			return ctx.Game.Players[ctx.TargetUID], ctx.TargetUID, nil
		}
		if ctx.Target != nil {
			return ctx.Game.Players[ctx.Target.Owner], ctx.Target.Owner, nil
		}
		return nil, "", fmt.Errorf("no target specified")
	default:
		// Try as direct UID
		if p, ok := ctx.Game.Players[ref]; ok {
			return p, ref, nil
		}
		return nil, "", fmt.Errorf("unknown player reference: %s", ref)
	}
}

// scriptDraw: Draw(count, source, target)
// source: "main", "vault"
// target: "caster", "opponent"
func scriptDraw(args []string, ctx *ScriptContext) []Event {
	if len(args) < 3 {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "Draw requires 3 arguments: count, source, target"}}}
	}

	count, err := strconv.Atoi(args[0])
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid count: " + args[0]}}}
	}

	source := strings.ToLower(strings.TrimSpace(args[1]))
	player, playerUID, err := resolvePlayer(args[2], ctx)
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": err.Error()}}}
	}

	var drawn []int
	switch source {
	case "main", "deck":
		drawn = player.DrawCards(count)
	case "vault", "land":
		drawn = player.DrawFromVault(count)
	default:
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid source: " + source}}}
	}

	return []Event{{
		Type: "ScriptDraw",
		Data: map[string]interface{}{
			"player":       playerUID,
			"source":       source,
			"count":        len(drawn),
			"cards":        drawn,
			"mainDeckSize": len(player.DrawPile),
			"vaultSize":    len(player.VaultPile),
		},
	}}
}

// scriptDamage: Damage(amount, target)
// target: "opponent", "target" (creature), creature instanceId
func scriptDamage(args []string, ctx *ScriptContext) []Event {
	if len(args) < 2 {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "Damage requires 2 arguments: amount, target"}}}
	}

	amount, err := strconv.Atoi(args[0])
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid amount: " + args[0]}}}
	}

	targetRef := strings.ToLower(strings.TrimSpace(args[1]))

	// Check if targeting a player
	if targetRef == "opponent" || targetRef == "enemy" {
		player, playerUID, err := resolvePlayer(targetRef, ctx)
		if err != nil {
			return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": err.Error()}}}
		}
		player.Life -= amount

		events := []Event{{
			Type: "ScriptDamage",
			Data: map[string]interface{}{
				"targetType":   "player",
				"targetPlayer": playerUID,
				"amount":       amount,
				"newLife":      player.Life,
			},
		}}

		// Check for death
		if player.Life <= 0 {
			for uid := range ctx.Game.Players {
				if uid != playerUID {
					ctx.Game.Winner = uid
					events = append(events, Event{
						Type: "GameOver",
						Data: map[string]interface{}{"winner": uid},
					})
					break
				}
			}
		}
		return events
	}

	// Check if targeting a creature
	if targetRef == "target" && ctx.Target != nil {
		ctx.Target.CurrentHealth -= amount
		return []Event{{
			Type: "ScriptDamage",
			Data: map[string]interface{}{
				"targetType":       "creature",
				"targetInstanceId": ctx.Target.InstanceID,
				"amount":           amount,
				"newHealth":        ctx.Target.CurrentHealth,
			},
		}}
	}

	// Try as instance ID
	instanceID, err := strconv.Atoi(targetRef)
	if err == nil {
		// Find creature by instance ID
		for _, player := range ctx.Game.Players {
			for _, fc := range player.Field {
				if fc.InstanceID == instanceID {
					fc.CurrentHealth -= amount
					return []Event{{
						Type: "ScriptDamage",
						Data: map[string]interface{}{
							"targetType":       "creature",
							"targetInstanceId": fc.InstanceID,
							"amount":           amount,
							"newHealth":        fc.CurrentHealth,
						},
					}}
				}
			}
		}
	}

	return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid target: " + targetRef}}}
}

// scriptHeal: Heal(amount, target)
// target: "caster", "opponent", "target" (creature)
func scriptHeal(args []string, ctx *ScriptContext) []Event {
	if len(args) < 2 {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "Heal requires 2 arguments: amount, target"}}}
	}

	amount, err := strconv.Atoi(args[0])
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid amount: " + args[0]}}}
	}

	targetRef := strings.ToLower(strings.TrimSpace(args[1]))

	// Check if targeting a player
	if targetRef == "caster" || targetRef == "self" || targetRef == "opponent" {
		player, playerUID, err := resolvePlayer(targetRef, ctx)
		if err != nil {
			return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": err.Error()}}}
		}
		player.Life += amount
		return []Event{{
			Type: "ScriptHeal",
			Data: map[string]interface{}{
				"targetType":   "player",
				"targetPlayer": playerUID,
				"amount":       amount,
				"newLife":      player.Life,
			},
		}}
	}

	// Check if targeting a creature
	if targetRef == "target" && ctx.Target != nil {
		maxHealth := ctx.Target.GetMaxHealth()
		ctx.Target.CurrentHealth += amount
		if ctx.Target.CurrentHealth > maxHealth {
			ctx.Target.CurrentHealth = maxHealth
		}
		return []Event{{
			Type: "ScriptHeal",
			Data: map[string]interface{}{
				"targetType":       "creature",
				"targetInstanceId": ctx.Target.InstanceID,
				"amount":           amount,
				"newHealth":        ctx.Target.CurrentHealth,
			},
		}}
	}

	return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid target: " + targetRef}}}
}

// scriptBuff: Buff(attack, health, target)
// Modifies a creature's attack and health modifiers
func scriptBuff(args []string, ctx *ScriptContext) []Event {
	if len(args) < 3 {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "Buff requires 3 arguments: attack, health, target"}}}
	}

	attackMod, err := strconv.Atoi(args[0])
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid attack modifier: " + args[0]}}}
	}

	healthMod, err := strconv.Atoi(args[1])
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid health modifier: " + args[1]}}}
	}

	targetRef := strings.ToLower(strings.TrimSpace(args[2]))

	var target *FieldCard
	if targetRef == "target" && ctx.Target != nil {
		target = ctx.Target
	} else if targetRef == "self" && ctx.Card != nil {
		target = ctx.Card
	} else {
		// Try as instance ID
		instanceID, err := strconv.Atoi(targetRef)
		if err == nil {
			for _, player := range ctx.Game.Players {
				for _, fc := range player.Field {
					if fc.InstanceID == instanceID {
						target = fc
						break
					}
				}
			}
		}
	}

	if target == nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid target: " + targetRef}}}
	}

	target.DamageModifier += attackMod
	target.HealthModifier += healthMod
	target.CurrentHealth += healthMod // Increase current health too

	return []Event{{
		Type: "ScriptBuff",
		Data: map[string]interface{}{
			"targetInstanceId": target.InstanceID,
			"attackMod":        attackMod,
			"healthMod":        healthMod,
			"newAttack":        target.GetAttack(),
			"newMaxHealth":     target.GetMaxHealth(),
			"newHealth":        target.CurrentHealth,
		},
	}}
}

// scriptGainMana: GainMana(color, amount, target)
// color: "white", "blue", "black", "red", "green", "colorless"
func scriptGainMana(args []string, ctx *ScriptContext) []Event {
	if len(args) < 3 {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "GainMana requires 3 arguments: color, amount, target"}}}
	}

	color := strings.ToLower(strings.TrimSpace(args[0]))
	amount, err := strconv.Atoi(args[1])
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid amount: " + args[1]}}}
	}

	player, playerUID, err := resolvePlayer(args[2], ctx)
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": err.Error()}}}
	}

	added := ManaCost{}
	switch color {
	case "white", "w":
		player.ManaPool.White += amount
		added.White = amount
	case "blue", "u":
		player.ManaPool.Blue += amount
		added.Blue = amount
	case "black", "b":
		player.ManaPool.Black += amount
		added.Black = amount
	case "red", "r":
		player.ManaPool.Red += amount
		added.Red = amount
	case "green", "g":
		player.ManaPool.Green += amount
		added.Green = amount
	case "colorless", "c":
		player.ManaPool.Colorless += amount
		added.Colorless = amount
	default:
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid color: " + color}}}
	}

	return []Event{{
		Type: "ScriptManaAdded",
		Data: map[string]interface{}{
			"player":   playerUID,
			"added":    added,
			"manaPool": player.ManaPool,
		},
	}}
}

// scriptDiscard: Discard(count, target)
// Forces target player to discard random cards
func scriptDiscard(args []string, ctx *ScriptContext) []Event {
	if len(args) < 2 {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "Discard requires 2 arguments: count, target"}}}
	}

	count, err := strconv.Atoi(args[0])
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid count: " + args[0]}}}
	}

	player, playerUID, err := resolvePlayer(args[1], ctx)
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": err.Error()}}}
	}

	discarded := []int{}
	for i := 0; i < count && len(player.Hand) > 0; i++ {
		// Discard last card (could randomize)
		cardID := player.Hand[len(player.Hand)-1]
		player.Hand = player.Hand[:len(player.Hand)-1]
		player.Discard = append(player.Discard, cardID)
		discarded = append(discarded, cardID)
	}

	return []Event{{
		Type: "ScriptDiscard",
		Data: map[string]interface{}{
			"player":    playerUID,
			"discarded": discarded,
			"handSize":  len(player.Hand),
		},
	}}
}

// scriptDestroy: Destroy(target)
// Destroys target creature
func scriptDestroy(args []string, ctx *ScriptContext) []Event {
	if len(args) < 1 {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "Destroy requires 1 argument: target"}}}
	}

	targetRef := strings.ToLower(strings.TrimSpace(args[0]))

	var target *FieldCard
	var ownerUID string

	if targetRef == "target" && ctx.Target != nil {
		target = ctx.Target
		ownerUID = ctx.Target.Owner
	} else {
		// Try as instance ID
		instanceID, err := strconv.Atoi(targetRef)
		if err == nil {
			for uid, player := range ctx.Game.Players {
				for _, fc := range player.Field {
					if fc.InstanceID == instanceID {
						target = fc
						ownerUID = uid
						break
					}
				}
			}
		}
	}

	if target == nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid target: " + targetRef}}}
	}

	// Set health to 0 to mark for death
	target.CurrentHealth = 0

	return []Event{{
		Type: "ScriptDestroy",
		Data: map[string]interface{}{
			"targetInstanceId": target.InstanceID,
			"owner":            ownerUID,
		},
	}}
}

// scriptDamageCreature: DamageCreature(amount, target)
// Deals damage to a target creature
func scriptDamageCreature(args []string, ctx *ScriptContext) []Event {
	if len(args) < 2 {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "DamageCreature requires 2 arguments: amount, target"}}}
	}

	amount, err := strconv.Atoi(args[0])
	if err != nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid amount: " + args[0]}}}
	}

	targetRef := strings.ToLower(strings.TrimSpace(args[1]))

	var target *FieldCard

	if targetRef == "target" && ctx.Target != nil {
		target = ctx.Target
	} else {
		// Try as instance ID
		instanceID, err := strconv.Atoi(targetRef)
		if err == nil {
			for _, player := range ctx.Game.Players {
				for _, fc := range player.Field {
					if fc.InstanceID == instanceID {
						target = fc
						break
					}
				}
			}
		}
	}

	if target == nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid target creature: " + targetRef}}}
	}

	target.CurrentHealth -= amount

	return []Event{{
		Type: "ScriptDamage",
		Data: map[string]interface{}{
			"targetType":       "creature",
			"targetInstanceId": target.InstanceID,
			"amount":           amount,
			"newHealth":        target.CurrentHealth,
		},
	}}
}

// scriptTapCreature: TapCreature(target)
// Taps a target creature
func scriptTapCreature(args []string, ctx *ScriptContext) []Event {
	if len(args) < 1 {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "TapCreature requires 1 argument: target"}}}
	}

	targetRef := strings.ToLower(strings.TrimSpace(args[0]))

	var target *FieldCard
	var ownerUID string

	if targetRef == "target" && ctx.Target != nil {
		target = ctx.Target
		ownerUID = ctx.Target.Owner
	} else {
		// Try as instance ID
		instanceID, err := strconv.Atoi(targetRef)
		if err == nil {
			for uid, player := range ctx.Game.Players {
				for _, fc := range player.Field {
					if fc.InstanceID == instanceID {
						target = fc
						ownerUID = uid
						break
					}
				}
			}
		}
	}

	if target == nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid target creature: " + targetRef}}}
	}

	target.SetTapped(true)

	return []Event{{
		Type: "ScriptTap",
		Data: map[string]interface{}{
			"targetInstanceId": target.InstanceID,
			"owner":            ownerUID,
		},
	}}
}

// scriptBounce: Bounce(target)
// Returns a target creature to its owner's hand
func scriptBounce(args []string, ctx *ScriptContext) []Event {
	if len(args) < 1 {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "Bounce requires 1 argument: target"}}}
	}

	targetRef := strings.ToLower(strings.TrimSpace(args[0]))

	var target *FieldCard
	var owner *Player
	var ownerUID string

	if targetRef == "target" && ctx.Target != nil {
		target = ctx.Target
		ownerUID = ctx.Target.Owner
		owner = ctx.Game.Players[ownerUID]
	} else {
		// Try as instance ID
		instanceID, err := strconv.Atoi(targetRef)
		if err == nil {
			for uid, player := range ctx.Game.Players {
				for _, fc := range player.Field {
					if fc.InstanceID == instanceID {
						target = fc
						owner = player
						ownerUID = uid
						break
					}
				}
			}
		}
	}

	if target == nil || owner == nil {
		return []Event{{Type: "ScriptError", Data: map[string]interface{}{"error": "invalid target creature: " + targetRef}}}
	}

	// Remove from field
	newField := []*FieldCard{}
	for _, fc := range owner.Field {
		if fc.InstanceID != target.InstanceID {
			newField = append(newField, fc)
		}
	}
	owner.Field = newField

	// Add card back to hand
	owner.Hand = append(owner.Hand, target.CardID)

	return []Event{{
		Type: "ScriptBounce",
		Data: map[string]interface{}{
			"targetInstanceId": target.InstanceID,
			"cardId":           target.CardID,
			"owner":            ownerUID,
		},
	}}
}
